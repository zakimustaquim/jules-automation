# Feature Specification: Continuous Agent Loop

**Feature Branch**: `001-continuous-agent-loop`  
**Created**: January 16, 2026  
**Status**: Draft  
**Input**: User description: "Use the Jules API to continuously spawn new coding agents with the prompt 'Do something interesting in this codebase' and merge their PRs to iterate on the codebase over time."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Autonomous Agent Generation Loop (Priority: P1)

A developer wants to set up an automated system that continuously generates new coding agents, each with the prompt "Do something interesting in this codebase," allowing them to make autonomous contributions to the repository. The developer can start the automation, monitor progress, and let it run over an extended period (e.g., a weekend) without manual intervention.

**Why this priority**: This is the core value proposition of the systemâ€”the ability to spawn agents autonomously and repeatedly. Without this, the entire feature has no purpose.

**Independent Test**: Can be tested by: (1) starting the automation with a valid repository and credentials, (2) confirming that at least one Jules agent is created with the specified prompt, (3) verifying that the system successfully completes the agent's execution lifecycle. This delivers immediate value by proving the basic automation loop works.

**Acceptance Scenarios**:

1. **Given** the system is configured with valid Jules API credentials and GitHub repository credentials, **When** the user starts the automation, **Then** the system creates a new Jules agent with the prompt "Do something interesting in this codebase" within 30 seconds.

2. **Given** a Jules agent has been created and completed its work, **When** the agent's PR is ready for merge, **Then** the system automatically merges the PR into the target branch.

3. **Given** a PR has been successfully merged, **When** the merge completes, **Then** the system immediately spawns the next Jules agent with the same prompt, creating a continuous loop.

---

### User Story 2 - Error Handling and Recovery (Priority: P2)

The developer wants the system to handle errors gracefully without crashing, including API failures, GitHub authentication issues, and PR merge conflicts, with clear error reporting for debugging.

**Why this priority**: Robustness is important for a long-running unattended process, but core functionality still works even with basic error handling. Additional error cases improve reliability incrementally.

**Independent Test**: Can be tested by: (1) simulating an API error (e.g., network timeout), (2) verifying the system logs the error and continues to the next iteration, (3) confirming the system doesn't enter an infinite retry loop. This ensures the system fails predictably.

**Acceptance Scenarios**:

1. **Given** the Jules API returns a temporary error (e.g., 500 Internal Server Error), **When** the error occurs, **Then** the system logs the error, waits 5 minutes, and retries spawning the agent up to 3 times.

2. **Given** a GitHub API call fails with authentication error, **When** the error occurs, **Then** the system logs the error, pauses the loop, and alerts the developer with the specific credential issue.

3. **Given** a PR merge attempt fails due to merge conflicts, **When** the conflict occurs, **Then** the system logs the PR ID, halts the merge, and alerts the developer without attempting auto-resolution.

---

### Edge Cases

- What happens if an agent creates a malicious or harmful commit? (System should respect GitHub branch protections and require approval if configured)
- What happens if an agent creates a very large PR that takes an unusually long time to process? (System should have a timeout and move to the next agent)
- What happens if the same change is generated by multiple agents? (Depends on git history; conflicts would be handled as merge failures)
- What happens if the repository becomes unresponsive or deleted during operation? (System should fail and alert the developer)
- What happens if quota is exceeded? (System will fail; developer is responsible for managing quota)

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST accept Jules API credentials and GitHub repository credentials at startup or via configuration file.

- **FR-002**: System MUST spawn a new Jules agent with the prompt "Do something interesting in this codebase" by calling the Jules API with appropriate parameters.

- **FR-003**: System MUST track the status of spawned agents (pending, in-progress, completed) and persist this state.

- **FR-004**: System MUST automatically merge an agent's PR into the target branch once the agent's work is complete and the PR is created.

- **FR-005**: System MUST spawn the next agent immediately after the previous agent's PR is merged.

- **FR-006**: System MUST log all significant events (agent creation, PR merge, errors) with timestamps and relevant context.

- **FR-007**: System MUST implement retry logic for transient API errors (network timeouts, 5xx errors) with exponential backoff, up to 3 attempts per operation.

- **FR-008**: System MUST handle merge conflicts by logging the PR ID and pausing the loop to alert the developer, without attempting automatic resolution.

- **FR-009**: System MUST implement a configurable timeout for agent execution (e.g., 30 minutes); if exceeded, the system logs a timeout event and proceeds to the next agent.

- **FR-010**: System MUST support graceful shutdown, completing any in-flight operations and saving state before terminating.

- **FR-011**: System MUST validate repository access and credentials at startup and alert the developer if validation fails.

### Key Entities

- **Agent Instance**: Represents a single Jules agent execution, with properties: ID, prompt, status (pending/running/completed), start time, end time, PR ID, associated commit SHA.

- **Quota State**: Tracks API usage, with properties: total requests allowed per period, requests used, requests remaining, reset timestamp, last update time.

- **Execution Log**: Records all significant system events, with properties: timestamp, event type (agent_created, pr_merged, quota_exhausted, error, etc.), agent ID (if applicable), message, error details (if applicable).

- **Configuration**: System settings, with properties: Jules API key, GitHub token, target repository (owner/repo), target branch for merges, request quota limit, quota reset period, agent prompt, execution timeout, retry policy.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: The system successfully spawns a new Jules agent within 30 seconds of the previous agent's PR being merged.

- **SC-002**: The system automatically merges 95% of successfully completed agent PRs without manual intervention.

- **SC-003**: The system respects the daily request quota and does not exceed it; quota exhaustion is logged and the loop pauses gracefully.

- **SC-004**: The system logs all major events and can be monitored by a developer with less than 1 minute of daily active monitoring (i.e., logging is comprehensive enough to diagnose issues without active supervision).

- **SC-005**: Over a 48-hour continuous run with a 100-requests-per-day quota, the system successfully spawns and integrates at least 10 agent PRs without human intervention (accounting for 2-day quota = ~200 requests).

- **SC-006**: The system recovers from transient API errors (network timeouts, temporary service unavailability) and continues the loop without data loss.

- **SC-007**: When a merge conflict occurs, the system logs the conflict, pauses gracefully, and alerts the developer within 1 minute of detection.

- **SC-008**: The system can be gracefully shut down within 30 seconds of receiving a shutdown signal, with all in-flight state saved.

## Assumptions

- Jules API is available and stable with documented rate limits and quota reset timing.
- GitHub API is available and the provided token has write access to create and merge PRs in the target repository.
- The target repository has branch protection rules that allow automated merges (or they are configured appropriately for the use case).
- The Gemini Pro API quota (100 requests per day) translates to Jules API request limits in a measurable way.
- The developer has administrative access to the repository and can configure webhooks or monitoring as needed.
- The system runs on a machine with persistent internet connectivity.
- The "interesting codebase" modifications generated by Jules agents are acceptable for the use case (i.e., the developer is willing to accept autonomous, potentially experimental changes).
- Merge conflicts are rare or acceptable to handle via developer intervention when they occur.

## Out of Scope

- Implementing Jules or GitHub APIs themselves (using existing public APIs).
- Modifying or filtering the prompt beyond "Do something interesting in this codebase."
- Automatic rollback or reversion of merged PRs.
- Performance optimization of Jules agent execution (this is Jules's responsibility).
- Multi-repository support (single repository focus).
- Complex approval workflows (system assumes merge is acceptable once agent completes).
